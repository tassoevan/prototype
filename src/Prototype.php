<?php
namespace TassoEvan\Prototype;

use \ArrayAccess;
use \BadMethodCallException;
use \Closure;

/**
 * This class represents objects whose properties have custom accessors.
 */
class Prototype implements ArrayAccess
{
	/**
	 * @param mixed $value
	 * @return TassoEvan\Prototype\NormalProperty
	 */
	public static function normal($value)
	{
		return new NormalProperty($value);
	}

	/**
	 * @param mixed $value
	 * @return TassoEvan\Prototype\ReadOnlyProperty
	 */
	public static function readOnly($value, $strict = false)
	{
		return new ReadOnlyProperty($value, $strict);
	}

	/**
	 * @param callable $loader
	 * @return TassoEvan\Prototype\LazyProperty
	 */
	public static function lazy(callable $loader)
	{
		return new LazyProperty($loader);
	}

	/**
	 * @param callable $getMiddleware
	 * @param callable $setMiddleware
	 * @param mixed $propertyOrValue
	 * @return TassoEvan\Prototype\ProxyProperty
	 */
	public static function proxy(callable $getMiddleware = null, callable $setMiddleware = null, $propertyOrValue = null)
	{
		return new ProxyProperty($getMiddleware, $setMiddleware, $propertyOrValue);
	}

	/**
	 * @param callable $getter
	 * @param callable $setter
	 * @return TassoEvan\Prototype\DynamicProperty
	 */
	public static function dynamic(callable $getter = null, callable $setter = null)
	{
		return new DynamicProperty($getter, $setter);
	}

	/**
	 * Constructs a closure for a generic callable
	 * @param callable $callable
	 * @return Closure
	 */
	public static function closure($callable)
	{
		return function() use($callable) {
			return call_user_func_array($callable, func_get_args());
		};
	}

	/**
	 * Creates a array of data generated by iterate over prototype properties
	 * @param Prototype $prototype
	 * @return array
	 */
	public static function data(Prototype $prototype)
	{
		$ret = array();

		foreach ( $prototype->properties as $key => $value )
			$ret[$key] = $prototype->offsetGet($key);

		return $ret;
	}

	private $invokable;
	private $properties = [];

	/**
	 * If a callable is provided, the own prototype becomes callable via __invoke() method.
	 * @param callable $invokable the closure that may be invoked
	 */
	public function __construct(callable $invokable = null)
	{
		if ($invokable !== null) {
			if ($invokable instanceof Closure) {
				$this->invokable = $invokable->bindTo($this);
			}
			else {
				$this->invokable = $invokable;
			}
		}
	}

	/**
	 * @see ArrayAccess::offsetExists()
	 */
	public function offsetExists($propertyName)
	{
		return isset($this->properties[$propertyName]);
	}

	/**
	 * @see ArrayAccess::offsetUnset()
	 */
	public function offsetUnset($propertyName)
	{
		unset($this->properties[$propertyName]);
	}

	/**
	 * @see ArrayAccess::offsetGet()
	 */
	public function offsetGet($propertyName)
	{
		$property = &$this->properties[$propertyName];

		return $property->get();
	}

	/**
	 * @see ArrayAccess::offsetSet()
	 */
	public function offsetSet($propertyName, $value)
	{
		$property = &$this->properties[$propertyName];

		if ($value instanceof Property) {
			$value->attachTo($this);
			return $property = $value;
		}
		elseif ($property instanceof Property) {
			return $property->set($value);
		}
		else {
			$this->properties[$propertyName] = new NormalProperty($value);
		}
	}

	/**
	 * @see __isset()
	 */
	public function __isset($propertyName)
	{
		return $this->offsetExists($propertyName);
	}

	/**
	 * @see __unset()
	 */
	public function __unset($propertyName)
	{
		$this->offsetUnset($propertyName);
	}

	/**
	 * @see __get()
	 */
	public function __get($propertyName)
	{
		return $this->offsetGet($propertyName);
	}

	/**
	 * @see __set()
	 */
	public function __set($propertyName, $value)
	{
		$this->offsetSet($propertyName, $value);
	}

	/**
	 * @see __call()
	 */
	public function __call($propertyName, array $args)
	{
		$property = &$this->properties[$propertyName];

		if (!$this->offsetExists($propertyName)) {
			throw new BadMethodCallException(sprintf('%s is undefined', $propertyName));
		}

		$callable = $this->offsetGet($propertyName);

		if (!is_callable($callable)) {
			throw new BadMethodCallException(sprintf('%s is not callable', $propertyName));
		}

		return call_user_func_array($callable, $args);
	}

	/**
	 * @see __invoke()
	 */
	public function __invoke(...$args)
	{
		if (is_callable($this->invokable)) {
			return call_user_func_array($this->invokable, $args);
		}
		else {
			throw new BadMethodCallException('Prototype is not invokable');
		}
	}
}
