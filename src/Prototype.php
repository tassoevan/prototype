<?php
namespace TassoEvan\Prototype;

use \ArrayAccess;
use \BadMethodCallException;
use \Closure;

/**
 * This class represents objects whose properties have custom accessors.
 */
class Prototype implements ArrayAccess
{
	/**
	 * Returns a pair containing <code>normal</code> access closures and the value.
	 * <code>Normal</code> access closures performs simple data storage
	 * @param mixed $value
	 * @return array
	 */
	public static function normal($value)
	{
		return [new NormalAccessor(), $value];
	}

	/**
	 * Returns a pair containing <code>dynamic</code> access closures and the value.
	 * <code>Dynamic</code> access closures always execute the passed <code>get</code>,
	 * <code>set</code> and <code>call</code> closures/prototypes for dynamic value
	 * creation, value storage and function call, respectively
	 * @param callable $get
	 * @param callable $set
	 * @param callable $call
	 * @return array
	 */
	public static function dynamic(callable $get = null, callable $set = null, callable $call = null)
	{
		return [new DynamicAccessor(), array($get, $set, $call)];
	}

	/**
	 * Returns a pair containing <code>lazy</code> access closures and the value.
	 * <code>lazy</code> access closures grants that stored data only will be
	 * generated on first access to property, performing lazy loading
	 * @param Closure $generator
	 * @return array
	 */
	public static function lazy(Closure $generator)
	{
		return [new LazyAccessor(), $generator];
	}

	/**
	 * Constructs a closure for a generic callable
	 * @param callable $callable
	 * @return Closure
	 */
	public static function closure($callable)
	{
		return function() use($callable) {
			return call_user_func_array($callable, func_get_args());
		};
	}

	/**
	 * Creates a array of data generated by iterate over prototype properties
	 * @param Prototype $prototype
	 * @return array
	 */
	public static function data(Prototype $prototype)
	{
		$ret = array();

		foreach ( $prototype->properties as $key => $value )
			$ret[$key] = $prototype->offsetGet($key);

		return $ret;
	}

	private $invokable;
	private $properties = [];

	/**
	 * If a closure is provided, the own prototype becomes callable via __invoke() method.
	 * @param Closure|null $invokable the closure that may be invoked
	 */
	public function __construct(Closure $invokable = null)
	{
		if ($invokable !== null) {
			$this->invokable = $invokable->bindTo($this);
		}
	}

	/**
	 * @see ArrayAccess::offsetExists()
	 */
	public function offsetExists($propertyName)
	{
		return isset($this->properties[$propertyName]);
	}

	/**
	 * @see ArrayAccess::offsetUnset()
	 */
	public function offsetUnset($propertyName)
	{
		unset($this->properties[$propertyName]);
	}

	/**
	 * @see ArrayAccess::offsetGet()
	 */
	public function offsetGet($propertyName)
	{
		return $this->properties[$propertyName][0]->get($this, $this->properties[$propertyName][1]);
	}

	/**
	 * @see ArrayAccess::offsetSet()
	 */
	public function offsetSet($propertyName, $value)
	{
		$valueIsPrototypeSet = is_array($value) && count($value) == 2 && isset($value[0]) && $value[0] instanceof Accessor;

		if ( $valueIsPrototypeSet ) {
			$this->properties[$propertyName] = $value;
		}
		elseif ( isset($this->properties[$propertyName]) ) {
			$this->properties[$propertyName][0]->set($this, $this->properties[$propertyName][1], $value);
		}
		else {
			$this->properties[$propertyName] = [new NormalAccessor(), $value];
		}
	}

	/**
	 * @see __isset()
	 */
	public function __isset($propertyName)
	{
		return $this->offsetExists($propertyName);
	}

	/**
	 * @see __unset()
	 */
	public function __unset($propertyName)
	{
		$this->offsetUnset($propertyName);
	}

	/**
	 * @see __get()
	 */
	public function __get($propertyName)
	{
		return $this->offsetGet($propertyName);
	}

	/**
	 * @see __set()
	 */
	public function __set($propertyName, $value)
	{
		$this->offsetSet($propertyName, $value);
	}

	/**
	 * @see __call()
	 */
	public function __call($propertyName, array $args)
	{
		if ( !isset($this->properties[$propertyName]) )
			throw new BadMethodCallException(sprintf('%s is undefined', $propertyName));

		return $this->properties[$propertyName][0]->invoke($this, $this->properties[$propertyName][1], ...$args);
	}

	/**
	 * @see __invoke()
	 */
	public function __invoke()
	{
		if ( $this->invokable instanceof Closure )
			return call_user_func_array($this->invokable, func_get_args());
		else
			throw new BadMethodCallException('Prototype is not invokable');
	}
}
